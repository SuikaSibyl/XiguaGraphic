#include <CudaFunc.h>
#include "RTUtils.cuh"
#include "Utility.cuh"
#include "HitableList.cuh"
#include "Sphere.cuh"
#include "DevMaterial.cuh"
#include <Debug.h>

// #include "helper_math.h"

int iDivUp(int a, int b) { return a % b != 0 ? a / b + 1 : a / b; }

#define WIDTH 800
#define HEIGHT 600
#define SPP 10
#define BOUNCE 4
#define SPHERE_EPSILON 0.0001f
#define BOX_EPSILON 0.001f
#define RAY_EPSILON 0.05f;
#define M_PI 3.1415926f;

// enum class Material { Diffuse, Specular, Refractive };

// struct Sphere 
// {
//     __device__ float intersect(const Ray &ray) const
//     {
//         float t;
//         float3 dis = pos - ray.pos;
//         float proj = dot(dis, ray.dir);
//         float delta = proj * proj - dot(dis, dis) + radius * radius;

//         if (delta < 0) return 0;

//         delta = sqrtf(delta);
//         return (t = proj - delta) > SPHERE_EPSILON ? t : ((t = proj + delta) > SPHERE_EPSILON ? t : 0);
//     }

//     float radius;
//     float3 pos, emissionColor, mainColor;
//     Material material;
// };

// __constant__ Sphere spheres[] =
// {
//     { 1e5f, { -1e5f - 50.0f, 40.0f, 80.0f }, { 0.0f, 0.0f, 0.0f }, { 0.75f, 0.25f, 0.25f }, Material::Diffuse }, // Left 
//     { 1e5f, { 1e5f + 50.0f, 40.0f, 80.0f }, { 0.0f, 0.0f, 0.0f }, { 0.25f, 0.25f, 0.75f }, Material::Diffuse }, // Right 
//     { 1e5f, { 0.0f, 40.0f, -1e5f }, { 0.0f, 0.0f, 0.0f }, { 0.75f, 0.75f, 0.75f }, Material::Diffuse }, // Back 
//     { 1e5f, { 0.0f, 40.0f, 1e5f + 600.0f }, { 0.0f, 0.0f, 0.0f }, { 1.00f, 1.00f, 1.00f }, Material::Diffuse }, // Front 
//     { 1e5f, { 0.0f, -1e5f, 80.0f }, { 0.0f, 0.0f, 0.0f }, { 0.75f, 0.75f, 0.75f }, Material::Diffuse }, // Bottom 
//     { 1e5f, { 0.0f, 1e5f + 80.0f, 80.0f }, { 0.0f, 0.0f, 0.0f }, { 0.75f, 0.75f, 0.75f }, Material::Diffuse }, // Top 
//     { 16.0f, { -25.0f, 16.0f, 47.0f }, { 0.0f, 0.0f, 0.0f }, { 1.0f, 1.0f, 1.0f }, Material::Diffuse }, // small sphere 1
//     { 20.0f, { 25.0f, 20.0f, 78.0f }, { 0.0f, 0.0f, 0.0f }, { 1.0f, 1.0f, 1.0f }, Material::Diffuse }, // small sphere 2
//     { 600.0f, { 0.0f, 678.8f, 80.0f }, { 1.6f, 1.6f, 1.6f }, { 0.0f, 0.0f, 0.0f }, Material::Diffuse }  // Light
// };

// __device__ inline bool intersectScene(const Ray &ray, float &t, int &id) 
// {
//     t = FLT_MAX, id = -1;
//     int sphereNum = sizeof(spheres) / sizeof(Sphere);
//     for (int i = 0; i < sphereNum; i++)
//     {
//         float ct = spheres[i].intersect(ray);
//         if (ct != 0 && ct < t)
//         {  
//             t = ct;
//             id = i;
//         }
//     }
        
//     return id != -1;
// }

// __device__ float3 pathTrace(Ray &ray, uint *s1, uint *s2) 
// { 
//     float3 accumColor = make_float3(0.0f, 0.0f, 0.0f);
//     float3 mask = make_float3(1.0f, 1.0f, 1.0f);

//     for (int i = 0; i < BOUNCE; i++)
//     {
//         float t;
//         int id;

//         if (!intersectScene(ray, t, id))
//             return make_float3(0.0f, 0.0f, 0.0f);

//         const Sphere &obj = spheres[id];
//         float3 p = ray.pos + ray.dir * t; 
//         float3 n = normalize(p - obj.pos);
//         float3 nl = dot(n, ray.dir) < 0 ? n : n * -1;

//         accumColor += mask * obj.emissionColor;

//         float r1 = rand(s1, s2) * 3.1415926f * 2.0f;
//         float r2 = rand(s1, s2);
//         float r2s = sqrtf(r2);

//         float3 w = nl;
//         float3 u = normalize(cross((std::fabs(w.x) > std::fabs(w.y) ? make_float3(0, 1, 0) : make_float3(1, 0, 0)), w));
//         float3 v = cross(w, u);

//         float3 d = normalize(u*(cos(r1))*r2s + v*(sin(r1))*r2s + w*sqrtf(1 - r2));

//         ray.pos = p + nl * RAY_EPSILON;
//         ray.dir = d;

//         mask *= obj.mainColor * dot(d, nl) * 2;
//     }

//     return accumColor;
// }


__device__ Hitable *world;
__constant__ DevCamera camera;
__constant__ float c_time;

__device__ float3 color(const Ray& r, int seed, int i  = 0)
{
    HitRecord rec;
    if ((world)->hit(r, 0.0001, 100, rec))
    {
        if (i >= 5)
           return make_float3(0.0);
        
        Ray scattered;
        float3 attenuation;

        float fseed = hash(c_time + 1.*seed);
        if(rec.mat_ptr->scatter(r, rec, attenuation, scattered, fseed))
        {
            return attenuation * color(scattered, seed + 1, i+1);
        }
    }
    else
    {
        float3 unit_direction = normalize(r.dir);
        float tt = 0.5 * (unit_direction.y + 1.);
        return (1.0 - tt) * make_float3(1.0) + tt * make_float3(0.5f, 0.7, 1.0);
    }
}

__device__ float3 RayTrace(const Ray& r)
{
    int Bounce = 3;
    float3 col = make_float3(0);
    for(int i=0;i<Bounce;i++)
    {
        col = col + color(r,i,0);
    }
    col = col / (1. * Bounce);
    return col;
}

__global__ void MainCall(Hitable** hitable, cudaSurfaceObject_t surf, unsigned int width, unsigned int height, float time, int index)
{
    // sphere sp2 = new sphere(make_float3(0,-100.5,-1), 100);

    // checkCudaErrors(cudaMemcpyToSymbol(list[0], &sp1, sizeof(sphere)));
    // checkCudaErrors(cudaMemcpyToSymbol(list[1], &sp2, sizeof(sphere)));
    
    // Hitable *world = new HitableList(list, 2);
    
    // Get coordinate
    unsigned int x = blockIdx.x * blockDim.x + threadIdx.x;
    unsigned int y = blockIdx.y * blockDim.y + threadIdx.y;

    // If out of bounds, return
    if (y >= height | x >= width) return;

    // float sa = hash( dot( fragCoord, vec2(12.9898, 78.233) ) + 1113.1*float(iFrame) );
    
    // vec2 of = -0.5 + vec2( hash(sa+13.271), hash(sa+63.216) );
    // vec2 p = (-iResolution.xy + 2.0*(fragCoord+of)) / iResolution.y;

    // vec3 ro = vec3(0.0,0.0,0.0);
    // vec3 ta = vec3(1.5,0.7,1.5);

    // mat3  ca = setCamera( ro, ta, 0.0 );
    // vec3  rd = normalize( ca * vec3(p,-1.3) );

    // vec4 data = texture( iChannel0, fragCoord/iResolution.xy );
    // if( iFrame==0 ) data = vec4(0.0);
    
    // data += vec4( calculateColor( ro, rd, sa ), 1.0 );
    float4 pixel4{};
    surf2Dread(&pixel4, surf, x * 16, y);

    float u = float(x) / width;
    float v = float(y) / height;

    float3 color;

    float i = 0;
    Ray ray = camera.getRay(u, v, i);
    //Ray ray = camera.getRay(u, v);
    ////Ray ray2 = camera.getJerkRay(u, v, 0);
    //Dowhatever2(&camera, u, v, 0);

    if (index == 0)
    {
        color = make_float3(0,0,0);
        color = color + RayTrace(ray);
    }
    else
    {
        color = make_float3(pixel4.x, pixel4.y, pixel4.z);
        color = color + RayTrace(ray) * (1. / (index));
        color = color / (1 + 1. / index);
    }

    float4 pixel = make_float4(color, 1.0);
    // Write to the texture
    surf2Dwrite(pixel, surf, x * 16, y);

    // uint s1 = rand_uint(x + rand_uint(index));
    // uint s2 = rand_uint(y + rand_uint(index));

    
    // //Ray camRay(make_float3(0.0f, 52.0f, 300.0f), normalize(make_float3(0.0f, -0.05f, -1.0f)));
    // Ray camRay(make_float3(0.0f, 52.0f, 300.0f), normalize(make_float3(0.0f, -0.05f, -1.0f)));
    // float3 cx = make_float3(WIDTH * 0.5135 / HEIGHT, 0.0f, 0.0f);
    // float3 cy = normalize(cross(cx, camRay.dir)) * 0.5135;
    // float4 pixel4{};
    // // Read from input surface
    // surf2Dread(&pixel4, surf, x * 16, y);
    // float3 pixel = make_float3(0.0);

    // if (index == 0)
    // {
    //     float3 d = camRay.dir + cx * ((0.25 + x) / WIDTH - 0.5) + cy * ((0.25 + y) / HEIGHT - 0.5);
    //     //Ray ray(camRay.pos + d * 40, normalize(d));
    //     //Ray ray(make_float3(0,0,0),, normalize(d));

    //     //float3 col = color(camRay);

    //     float4 color = make_float4(clamp(col, 0.0f, 1.0f), 1.0f);
    //     surf2Dwrite(color, surf, x * 16, y);
    // }

    //if (index == 0)
    //{
    //    for (int s = 0; s < SPP; s++)
    //    {
    //        float3 d = camRay.dir + cx * ((0.25 + x) / WIDTH - 0.5) + cy * ((0.25 + y) / HEIGHT - 0.5);
    //        Ray ray(camRay.pos + d * 40, normalize(d));

    //        pixel += pathTrace(ray, &s1, &s2) * (1. / (SPP));
    //    }
    //}
    //else
    //{
    //    pixel = make_float3(pixel4.x, pixel4.y, pixel4.z);
    //    for (int s = 0; s < 10; s++)
    //    {
    //        float3 d = camRay.dir + cx * ((0.25 + x) / WIDTH - 0.5) + cy * ((0.25 + y) / HEIGHT - 0.5);
    //        Ray ray(camRay.pos + d * 40, normalize(d));

    //        pixel += pathTrace(ray, &s1, &s2) * (1. / (index *SPP ));
    //    }
    //    pixel = pixel / (1 + 1. / index);
    //}

    //float4 color = make_float4(clamp(pixel, 0.0f, 1.0f),1.0f);
    //surf2Dwrite(color, surf, x * 16, y);
}

__global__ void CreateScene(Hitable** hitable, int i)
{
    if (threadIdx.x == 0 && blockIdx.x == 0)
    {
        hitable[0] = new Sphere(make_float3(0, 0, -1), 0.5, new DevLambertian(make_float3(0.8,0.3,0.3)));
        hitable[1] = new Sphere(make_float3(0, -100.5, -1), 100, new DevLambertian(make_float3(0.8,0.8,0.0)));
        hitable[2] = new Sphere(make_float3(1, 0, -1), 0.5, new DevMetal(make_float3(0.8,0.6,0.2),0.3));
        hitable[3] = new Sphere(make_float3(-1, 0, -1), 0.5, new DevMetal(make_float3(0.8,0.8,0.8),1.));
        world = new HitableList(hitable,4);
    }
}

__global__ void DeleteOnDevice(Hitable** hitable)
{
    delete[](*hitable);
    hitable = nullptr;
}

extern "C" void RunKernel(size_t textureW, size_t textureH, cudaSurfaceObject_t surfaceObject, 
    cudaStream_t streamToRun, int i, float* paras)
{
    // // Create Scene
    Hitable** hitable = nullptr;
    cudaMalloc((void**)&hitable, 4 * sizeof(Hitable**));
    CreateScene<<<1,1>>>(hitable, i);

    // Create camera
    // DevCamera* tmp = new DevCamera(textureW, textureH);
    float3 lookfrom = make_float3(0.1*paras[0],0.1*paras[1],0.1*paras[2]);
    float3 lookat = make_float3(0.1*paras[3],0.1*paras[4],0.1*paras[5]);
    float dist_to_focus = length(lookfrom - lookat);
    float aperture = 2;

    DevCamera* tmp = new DevCamera(lookfrom, lookat, make_float3(0,1,0), 20, textureW/textureH, aperture, dist_to_focus);
    float animTime = 0.01 * i;
    checkCudaErrors(cudaMemcpyToSymbol(camera, tmp, sizeof(DevCamera),0,cudaMemcpyHostToDevice));
    checkCudaErrors(cudaMemcpyToSymbol(c_time, &animTime, sizeof(float),0,cudaMemcpyHostToDevice));

    // Emit main call kernel
    auto unit = 10;
    dim3 threads(unit, unit);
    dim3 grid(iDivUp(textureW, unit), iDivUp(textureH, unit));

    MainCall <<<grid, threads, 0, streamToRun >>> (hitable, surfaceObject, textureW, textureH, animTime, i);
    checkCudaErrors(cudaGetLastError());
}